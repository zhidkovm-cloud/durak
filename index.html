<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>–î—É—Ä–∞–∫ ‚Äî PWA v9.2</title>

<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#0f6b50">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="icons/apple-touch-icon.png">

<style>
  :root{
    --vw: min(100vw, 430px);
    --vh: 100dvh;
    --card-w: clamp(56px, calc(var(--vw)/6.0), 78px);
    --card-h: calc(var(--card-w) * 1.4);
    --pad: max(8px, env(safe-area-inset-left));
    --pad-r: max(8px, env(safe-area-inset-right));
    --pad-b: max(8px, env(safe-area-inset-bottom));
  }
  *{box-sizing:border-box}
  html, body { height: var(--vh); overflow: hidden; }
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial,sans-serif;
    background:linear-gradient(135deg,#dff5e6,#d7eef5);
    padding:0;
  }
  #root{
    height: var(--vh);
    max-width: 1100px;
    margin: 0 auto;
    display: grid;
    grid-template-rows: auto 1fr auto;
  }
  header{
    display:flex;gap:10px;align-items:center;justify-content:space-between;
    padding:8px var(--pad); padding-right: var(--pad-r);
  }
  .pill{padding:6px 10px;border-radius:999px;background:#fff;box-shadow:0 1px 2px #0002;border:1px solid #0001;font-size:14px}
  button{
    min-height:40px; min-width:40px;
    padding:8px 12px;border-radius:14px;border:1px solid #0002;background:#fff;box-shadow:0 1px 3px #0002; cursor:pointer; font-weight:600
  }
  button:active{transform:translateY(1px)}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:nowrap}
  .muted{opacity:.72}
  .topline{display:flex; justify-content:space-between; align-items:center; padding:0 var(--pad);}

  /* Middle board area fills available space, no scroll */
  .middle{
    display:grid;
    grid-template-columns: 1fr minmax(120px, 160px);
    gap:10px;
    align-items:stretch;
    padding:0 var(--pad);
    height: 100%;
  }
  .leftCol{
    display:grid;
    grid-template-rows: auto 1fr;
    gap:8px;
    min-width: 0;
  }
  .opponent-row{display:flex; justify-content:space-between; align-items:center; gap:8px}
  .opponent-hand{display:flex; gap: calc(var(--card-w) * -0.55); align-items:center; overflow:hidden}
  .table{
    height: 100%;
    border-radius:18px; background:#fff8; box-shadow:inset 0 0 0 1px #0001; position:relative;
    padding:12px; display:flex; flex-wrap:wrap; gap:12px; align-content:flex-start; overflow:hidden;
  }
  .pair{position:relative; width:var(--card-w); height:calc(var(--card-h)+18px)}
  .slot{position:absolute; width:var(--card-w); height:var(--card-h); border:2px dashed #0003; border-radius:10px; top:0}
  .def{position:absolute; top:14px; left:16px; transform:rotate(-10deg)}
  .hand{display:flex; gap: calc(var(--card-w) * -0.55); padding: 6px var(--pad) 8px var(--pad); overflow:hidden}
  .box{display:flex; flex-direction:column; gap:6px; align-items:stretch; padding:10px; border-radius:18px; background:#fff7; box-shadow:inset 0 0 0 1px #0001; height: fit-content}
  .stack{position:relative; width:calc(var(--card-w)+12px); height:calc(var(--card-h)+12px)}
  .stack .back{position:absolute; top:0; left:0; transform-origin:bottom right}
  .stack .back:nth-child(1){transform:translate(0px,0px) rotate(0deg)}
  .stack .back:nth-child(2){transform:translate(6px,4px) rotate(1deg)}
  .stack .back:nth-child(3){transform:translate(12px,8px) rotate(2deg)}
  .stack .back:nth-child(4){transform:translate(18px,12px) rotate(3deg)}
  /* Trump half under stack, fixed perpendicular, no transitions */
  .trump-half{
    position:absolute; bottom:-8px; left:-22px;
    transform:rotate(90deg);
    transform-origin:bottom left;
    filter:drop-shadow(0 2px 6px rgba(0,0,0,.3));
    z-index:0; pointer-events:none;
    transition:none !important;
  }
  .card{user-select:none; width:var(--card-w); height:var(--card-h); border-radius:12px; background:#fff; box-shadow:0 2px 8px #0003; border:1px solid #0002; padding:6px; display:flex; flex-direction:column; justify-content:space-between; transition: transform var(--animDur, .28s) ease, opacity var(--animDur, .28s) ease}
  .card.red{color:#c62828}
  .back{width:var(--card-w); height:var(--card-h); border-radius:12px; background:repeating-linear-gradient(45deg,#e3f2fd,#e3f2fd 6px,#bbdefb 6px,#bbdefb 12px); box-shadow:0 2px 8px #0003; border:1px solid #0002; z-index:1; position:relative}
  .small{font-size:13px;font-weight:700}
  .big{font-size:20px;font-weight:800; text-align:center}
  .grow{flex:1}
  .appear{animation: pop var(--animDur, .25s) ease-out}
  @keyframes pop{ from{transform:scale(.96); opacity:.0} to{transform:scale(1); opacity:1} }
  .chat{display:flex; gap:6px; align-items:center}
  .emoji-btn{font-size:18px; background:#fff; border:1px solid #0002; border-radius:12px; padding:6px 8px; cursor:pointer; min-width:40px; min-height:40px}
  .timer{padding:6px 10px;border-radius:12px; background:#fff; border:1px solid #0002; min-width:86px; text-align:center}
  .toast{position:fixed; left:50%; transform:translateX(-50%); bottom:calc(14px + env(safe-area-inset-bottom)); background:#1b5e20; color:#fff; padding:8px 12px; border-radius:999px; box-shadow:0 6px 24px #0005; display:none; z-index:99999}
  dialog{border:none; border-radius:16px; padding:16px; box-shadow:0 10px 40px #0003; max-width:92vw;width:clamp(280px,78vw,420px)}
  dialog::backdrop{background:rgba(0,0,0,.25)}
</style>
</head>
<body>
<div id="root">
  <header>
    <div class="row">
      <div class="pill">–ö–æ–∑—ã—Ä—å: <span id="trumpSym">?</span></div>
      <div class="pill">–í –∫–æ–ª–æ–¥–µ: <span id="deckLeft">36</span></div>
      <div id="turnTimer" class="timer muted">‚Äî</div>
    </div>
    <div class="row">
      <div id="status" class="pill muted" style="max-width:56vw; white-space:nowrap; overflow:hidden; text-overflow:ellipsis">‚Äî</div>
      <button id="menuBtn" title="–ú–µ–Ω—é">‚ãØ</button>
    </div>
  </header>

  <div class="topline">
    <div class="opponent-row" style="flex:1">
      <div class="muted">–û–ø–ø–æ–Ω–µ–Ω—Ç: <span id="botCount">0</span> –∫–∞—Ä—Ç</div>
      <div class="opponent-hand" id="opponentHand"></div>
      <div class="row chat">
        <button class="emoji-btn" data-emo="üëç">üëç</button>
        <button class="emoji-btn" data-emo="üòÖ">üòÖ</button>
        <button class="emoji-btn" data-emo="üî•">üî•</button>
        <button class="emoji-btn" data-emo="üëè">üëè</button>
      </div>
      <div class="row" style="gap:8px">
        <button id="takeBtn">–ë–µ—Ä—É</button>
        <button id="bitoBtn">–ë–∏—Ç–æ</button>
      </div>
    </div>
  </div>

  <main class="middle">
    <div class="leftCol">
      <div class="table" id="table"></div>
      <div class="hand" id="you"></div>
    </div>
    <div class="box" id="deckBox">
      <div class="pill">–ö–æ–ª–æ–¥–∞</div>
      <div class="stack" id="deckStack" style="margin-bottom:20px; position:relative"></div>
    </div>
  </main>
</div>

<div id="toast" class="toast"></div>

<!-- Confirm Bito -->
<dialog id="bitoConfirmDlg">
  <h3 style="margin:0 0 10px 0">–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å ¬´–ë–∏—Ç–æ¬ª?</h3>
  <p class="muted" style="margin-top:0">–•–æ–¥ –∞—Ç–∞–∫—É—é—â–µ–≥–æ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è, –∫–∞—Ä—Ç—ã —É–π–¥—É—Ç –≤ –æ—Ç–±–æ–π.</p>
  <div class="row" style="justify-content:flex-end">
    <button id="bitoCancel">–û—Ç–º–µ–Ω–∞</button>
    <button id="bitoOk">–ë–∏—Ç–æ</button>
  </div>
</dialog>

<!-- Throw-in dialog -->
<dialog id="throwDlg">
  <h3 style="margin:0 0 10px 0">–û—Ç–¥–∞—Ç—å / –ø–æ–¥–∫–∏–Ω—É—Ç—å</h3>
  <p id="throwInfo" class="muted" style="margin-top:0"></p>
  <div id="throwGrid" class="grid-cards"></div>
  <div class="row" style="justify-content:flex-end; margin-top:10px">
    <button id="throwCancel">–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å</button>
    <button id="throwOk">–û—Ç–¥–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—ã–µ</button>
  </div>
</dialog>

<!-- SETTINGS DIALOG -->
<dialog id="settingsDlg">
  <h3 style="margin:0 0 10px 0">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
  <div class="row" style="gap:16px; flex-direction:column; align-items:stretch">
    <label>–°–ª–æ–∂–Ω–æ—Å—Ç—å –±–æ—Ç–∞
      <select id="difficulty" style="width:100%">
        <option value="easy">–õ—ë–≥–∫–∞—è</option>
        <option value="normal" selected>–û–±—ã—á–Ω–∞—è</option>
        <option value="hard">–°–ª–æ–∂–Ω–∞—è</option>
      </select>
    </label>
    <label>–°–∫–æ—Ä–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–π (<span id="animVal">1.0x</span>)
      <input id="animRange" type="range" min="0.5" max="2.0" step="0.1" value="1.0">
    </label>
    <label>–ì—Ä–æ–º–∫–æ—Å—Ç—å –∑–≤—É–∫–∞ (<span id="volVal">70%</span>)
      <input id="volRange" type="range" min="0" max="1" step="0.05" value="0.7">
    </label>
    <label>–ó–∞–¥–µ—Ä–∂–∫–∞ ¬´–ë–∏—Ç–æ¬ª —É –±–æ—Ç–∞ (<span id="bitoDelayVal">0.8—Å</span>)
      <input id="bitoDelayRange" type="range" min="0.0" max="2.0" step="0.1" value="0.8">
    </label>
    <label>–õ–∏–º–∏—Ç –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ —Ö–æ–¥ (<span id="turnLimitVal">‚Äî</span>)
      <input id="turnLimitRange" type="range" min="0" max="30" step="1" value="0">
      <div class="muted" style="font-size:12px">0 = –±–µ–∑ —Ç–∞–π–º–µ—Ä–∞</div>
    </label>
    <label><input type="checkbox" id="saveToggle" checked> –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–∞—Ä—Ç–∏–∏</label>
  </div>
  <div class="row" style="justify-content:flex-end; margin-top:12px">
    <button id="settingsClose">–ó–∞–∫—Ä—ã—Ç—å</button>
  </div>
</dialog>

<!-- MENU DIALOG -->
<dialog id="menuDlg">
  <h3 style="margin:0 0 10px 0">–ú–µ–Ω—é</h3>
  <div class="row" style="gap:10px; flex-direction:column; align-items:stretch">
    <button id="menuNew">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
    <button id="menuSettings">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
    <button id="menuOnline">–ò–≥—Ä–∞ —Å –¥—Ä—É–≥–æ–º</button>
  </div>
  <div class="row" style="justify-content:flex-end; margin-top:12px">
    <button id="menuClose">–ó–∞–∫—Ä—ã—Ç—å</button>
  </div>
</dialog>

<!-- ONLINE DIALOG -->
<dialog id="onlineDlg">
  <h3 style="margin:0 0 10px 0">–ò–≥—Ä–∞ —Å –¥—Ä—É–≥–æ–º (P2P)</h3>
  <p class="muted">–ö–æ–ø–∏–ø–∞—Å—Ç-—Å–∏–≥–Ω–∞–ª–∏–Ω–≥, STUN Google. –ë—Ä–æ—Å–æ–∫/–æ—Ç–¥–∞—á–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω—ã.</p>
  <div class="row" style="gap:12px; flex-direction:column; align-items:stretch">
    <div class="box">
      <h4 style="margin:0 0 6px 0">–°–æ–∑–¥–∞—Ç—å –∏–≥—Ä—É</h4>
      <div class="row">
        <button id="hostCreate">–°–æ–∑–¥–∞—Ç—å –æ—Ñ—Ñ–µ—Ä</button>
        <button id="hostCopy">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –æ—Ñ—Ñ–µ—Ä</button>
      </div>
      <textarea id="hostOffer" placeholder="–û—Ñ—Ñ–µ—Ä –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å"></textarea>
      <div class="row">
        <button id="hostSetAnswer">–í—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç –¥—Ä—É–≥–∞</button>
        <button id="hostPaste">–í—Å—Ç–∞–≤–∏—Ç—å –∏–∑ –±—É—Ñ–µ—Ä–∞</button>
      </div>
      <textarea id="hostAnswer" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ —Å—é–¥–∞ –æ—Ç–≤–µ—Ç (answer)"></textarea>
    </div>
    <div class="box">
      <h4 style="margin:0 0 6px 0">–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è</h4>
      <div class="row">
        <button id="guestPasteOffer">–í—Å—Ç–∞–≤–∏—Ç—å –æ—Ñ—Ñ–µ—Ä –∏–∑ –±—É—Ñ–µ—Ä–∞</button>
      </div>
      <textarea id="guestOffer" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ –æ—Ñ—Ñ–µ—Ä (offer)"></textarea>
      <div class="row">
        <button id="guestCreateAnswer">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–≤–µ—Ç</button>
        <button id="guestCopyAnswer">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–≤–µ—Ç</button>
      </div>
      <textarea id="guestAnswer" placeholder="–°–∫–æ–ø–∏—Ä—É–π—Ç–µ —ç—Ç–æ—Ç –æ—Ç–≤–µ—Ç –¥—Ä—É–≥—É"></textarea>
    </div>
  </div>
  <p id="netState" class="muted">–°–æ—Å—Ç–æ—è–Ω–∏–µ: –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–æ</p>
  <div class="row" style="justify-content:flex-end; margin-top:12px">
    <button id="onlineClose">–ó–∞–∫—Ä—ã—Ç—å</button>
  </div>
</dialog>

<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => navigator.serviceWorker.register('./sw.js').catch(console.error));
}
</script>

<script>
(function(){
  // SETTINGS & SAVE
  const settings = JSON.parse(localStorage.getItem('durak_settings_v9_2')||'{}');
  const gameKey = 'durak_save_v9_2';
  let config = { difficulty: settings.difficulty || 'normal', animSpeed: settings.animSpeed || 1.0, volume: settings.volume ?? 0.7, autosave: settings.autosave ?? true, bitoDelay: settings.bitoDelay ?? 0.8, turnLimit: settings.turnLimit ?? 0 };
  document.documentElement.style.setProperty('--animDur', (0.28/config.animSpeed)+'s');

  // MENU
  const menuDlg = document.getElementById('menuDlg');
  document.getElementById('menuBtn').onclick = ()=> menuDlg.showModal();
  document.getElementById('menuClose').onclick = ()=> menuDlg.close();
  document.getElementById('menuNew').onclick = ()=> { start(true); sfx('deal'); menuDlg.close(); };
  document.getElementById('menuSettings').onclick = ()=> { menuDlg.close(); document.getElementById('settingsDlg').showModal(); };
  document.getElementById('menuOnline').onclick = ()=> { menuDlg.close(); document.getElementById('onlineDlg').showModal(); };

  const dlg = document.getElementById('settingsDlg');
  const difficultySel = document.getElementById('difficulty');
  const animRange = document.getElementById('animRange');
  const volRange = document.getElementById('volRange');
  const saveToggle = document.getElementById('saveToggle');
  const bitoDelayRange = document.getElementById('bitoDelayRange');
  const turnLimitRange = document.getElementById('turnLimitRange');
  const animVal = document.getElementById('animVal');
  const volVal = document.getElementById('volVal');
  const bitoDelayVal = document.getElementById('bitoDelayVal');
  const turnLimitVal = document.getElementById('turnLimitVal');
  difficultySel.value = config.difficulty; animRange.value = config.animSpeed; volRange.value = config.volume; saveToggle.checked = config.autosave; bitoDelayRange.value = config.bitoDelay; turnLimitRange.value = config.turnLimit;
  animVal.textContent = config.animSpeed.toFixed(1)+'x'; volVal.textContent = Math.round(config.volume*100)+'%'; bitoDelayVal.textContent = config.bitoDelay.toFixed(1)+'—Å'; turnLimitVal.textContent = config.turnLimit ? (config.turnLimit+'—Å') : '‚Äî';
  document.getElementById('settingsClose').onclick = ()=> dlg.close();
  animRange.oninput = ()=> { config.animSpeed = parseFloat(animRange.value); animVal.textContent = config.animSpeed.toFixed(1)+'x'; document.documentElement.style.setProperty('--animDur', (0.28/config.animSpeed)+'s'); saveSettings(); };
  volRange.oninput = ()=> { config.volume = parseFloat(volRange.value); volVal.textContent = Math.round(config.volume*100)+'%'; saveSettings(); };
  difficultySel.onchange = ()=> { config.difficulty = difficultySel.value; saveSettings(); };
  saveToggle.onchange = ()=> { config.autosave = saveToggle.checked; saveSettings(); };
  bitoDelayRange.oninput = ()=> { config.bitoDelay = parseFloat(bitoDelayRange.value); bitoDelayVal.textContent = config.bitoDelay.toFixed(1)+'—Å'; saveSettings(); };
  turnLimitRange.oninput = ()=> { config.turnLimit = parseInt(turnLimitRange.value); turnLimitVal.textContent = config.turnLimit ? (config.turnLimit+'—Å') : '‚Äî'; saveSettings(); };
  function saveSettings(){ localStorage.setItem('durak_settings_v9_2', JSON.stringify(config)) }

  // AUDIO
  let audioCtx = null;
  function ensureAudio(){ if(!audioCtx){ try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){} } }
  function sfx(name){
    if(!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    o.type = 'triangle';
    const now = audioCtx.currentTime;
    let f=400, t=0.08, vol = Math.max(0.0001, config.volume*0.15);
    if(name==='place'){ f=420; t=0.07 }
    else if(name==='defend'){ f=340; t=0.10 }
    else if(name==='bito'){ f=220; t=0.12 }
    else if(name==='take'){ f=180; t=0.14 }
    else if(name==='deal'){ f=520; t=0.05 }
    else if(name==='transfer'){ f=300; t=0.09 }
    else if(name==='tick'){ f=600; t=0.02 }
    o.frequency.setValueAtTime(f, now);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(vol, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + t/config.animSpeed);
    o.start(now); o.stop(now + t/config.animSpeed);
  }
  document.body.addEventListener('pointerdown', ()=>{ ensureAudio(); if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); }, { once:true });

  // STATE (copied from v9.1 with single-screen UI)
  const SUITS = ["‚ô†","‚ô•","‚ô¶","‚ô£"];
  const RED = new Set(["‚ô•","‚ô¶"]);
  const RANKS = [6,7,8,9,10,'–í','–î','–ö','–¢'];
  let cardAutoId = 0;
  let net = { mode:'offline', role:null, pc:null, dc:null, ready:false };
  const state = { deck: [], trump: null, trumpCard: null, you: [], bot: [], table: [], attacker: 'you', gameOver:false, discard: [], bout:{capacity:6, started:false} };

  // Timer
  let timerId = null, timeLeft = 0;
  const $timer = document.getElementById('turnTimer');
  function startTimer(){ clearInterval(timerId); timeLeft = config.turnLimit; renderTimer(); if(config.turnLimit<=0) return;
    timerId = setInterval(()=>{ timeLeft--; renderTimer(); if(timeLeft<=3 && timeLeft>0) sfx('tick'); if(timeLeft<=0){ clearInterval(timerId); onTimerExpired(); } }, 1000); }
  function renderTimer(){ $timer.textContent = config.turnLimit ? (timeLeft>0? `–•–æ–¥: ${timeLeft}—Å` : '‚Äî') : '‚Äî'; }
  function onTimerExpired(){
    if(uncoveredIdx()===-1){ if(state.table.length){ endBout(false); } }
    else { endBout(true); }
  }

  // Helpers
  function newDeck(){
    const cards=[]; for(const s of SUITS){ for(const r of RANKS){ cards.push({id: (++cardAutoId)+'', suit:s, rank:r}); } }
    shuffle(cards); state.trumpCard = cards[cards.length-1]; state.trump = state.trumpCard.suit; return cards;
  }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } }
  function rankVal(r){ return typeof r==='number'?r: ({'–í':11,'–î':12,'–ö':13,'–¢':14}[r]); }
  function canBeat(c, other){ if(c.suit===other.suit) return rankVal(c.rank)>rankVal(other.rank); if(c.suit===state.trump && other.suit!==state.trump) return true; return false; }
  function defender(){ return state.attacker==='you'?'bot':'you' }
  function hand(of){ return of==='you'?state.you:state.bot }
  function uncoveredIdx(){ for(let i=0;i<state.table.length;i++) if(!state.table[i].d) return i; return -1 }
  function ranksOnTable(){ const s=new Set(); for(const p of state.table){ s.add(p.a.rank); if(p.d) s.add(p.d.rank) } return s }
  function maxPairs(){ return Math.min(6, state.bout.capacity); }
  function canAddAttack(){ if(state.table.length>=maxPairs()) return false; if(state.table.length===0) return true; const rs=ranksOnTable(); return hand(state.attacker).some(c=>rs.has(c.rank)); }
  function hasAnyDefense(){ return state.table.some(p=>!!p.d) }
  function canTransferBy(role, card){ if (role !== defender()) return false; if (hasAnyDefense()) return false; const idx = uncoveredIdx(); if (idx === -1) return false; const rs = ranksOnTable(); if (!rs.has(card.rank)) return false; const after = state.table.length + 1; const newCapacity = (state.attacker==='you'? state.you.length : state.bot.length); return after <= Math.min(6, newCapacity); }

  // UI refs
  const $trump = document.getElementById('trumpSym');
  const $deckLeft = document.getElementById('deckLeft');
  const $status = document.getElementById('status');
  const $you = document.getElementById('you');
  const $youCount = document.getElementById('youCount');
  const $botCount = document.getElementById('botCount');
  const $table = document.getElementById('table');
  const $take = document.getElementById('takeBtn');
  const $bito = document.getElementById('bitoBtn');
  const $deckStack = document.getElementById('deckStack');
  const $opponentHand = document.getElementById('opponentHand');
  const $toast = document.getElementById('toast');
  const $botCountSpan = document.getElementById('botCount');

  // dialogs
  const bitoDlg = document.getElementById('bitoConfirmDlg');
  document.getElementById('bitoCancel').onclick = ()=> bitoDlg.close();
  document.getElementById('bitoOk').onclick = ()=>{ bitoDlg.close(); endBout(false); };
  const throwDlg = document.getElementById('throwDlg');
  const throwInfo = document.getElementById('throwInfo');
  const throwGrid = document.getElementById('throwGrid');
  document.getElementById('throwCancel').onclick = ()=>{ throwDlg.close(); finalizeTake(); };
  document.getElementById('throwOk').onclick = ()=>{ commitThrowAndTake(); };

  function showToast(msg){ $toast.textContent=msg; $toast.style.display='block'; setTimeout(()=>{ $toast.style.display='none' }, 1500); }

  // Render helpers
  function renderCard(c, opts={}){
    const el=document.createElement('div'); el.className='card'+(RED.has(c.suit)?' red':'');
    el.dataset.id = c.id;
    el.innerHTML=`<div class="small">${c.rank}<span class="grow"></span>${c.suit}</div><div class="big">${c.rank}${c.suit}</div><div class="small">${c.suit}<span class="grow"></span>${c.rank}</div>`;
    if(opts.onClick) el.onclick=opts.onClick;
    el.classList.add('appear');
    return el;
  }
  function renderBack(){ const el=document.createElement('div'); el.className='back appear'; return el }

  function update(){
    document.documentElement.style.setProperty('--animDur', (0.28/config.animSpeed)+'s');
    $trump.textContent = state.trump||'?';
    $deckLeft.textContent = state.deck.length;
    $youCount.textContent = state.you.length; $botCountSpan.textContent = state.bot.length;

    // Deck & trump half UNDER stack
    $deckStack.innerHTML='';
    // add trump first (lower z), then backs
    if(state.deck.length>0 && state.trumpCard){
      const half = renderCard(state.trumpCard);
      half.classList.remove('appear'); // avoid transform animation
      half.classList.add('trump-half');
      $deckStack.appendChild(half);
    } else {
      const chip = document.createElement('div'); chip.className='pill'; chip.textContent='–ö–æ–∑—ã—Ä—å: '+(state.trump||'?'); $deckStack.appendChild(chip);
    }
    const backs = Math.min(4, Math.max(0, Math.ceil(state.deck.length/6)));
    for(let i=0;i<backs;i++){ $deckStack.appendChild(renderBack()); }

    const atk = net.mode==='online' ? (state.attacker==='you'?'–í—ã':'–î—Ä—É–≥') + ' –∞—Ç–∞–∫—É–µ—Ç' : (state.attacker==='you'? '–í—ã –∞—Ç–∞–∫—É–µ—Ç–µ' : '–ë–æ—Ç –∞—Ç–∞–∫—É–µ—Ç');
    const def = net.mode==='online' ? (defender()==='you'?'–í—ã':'–î—Ä—É–≥') + ' –∑–∞—â–∏—â–∞–µ—Ç—Å—è' : (defender()==='you'? '–í—ã –∑–∞—â–∏—â–∞–µ—Ç–µ—Å—å' : '–ë–æ—Ç –∑–∞—â–∏—â–∞–µ—Ç—Å—è');
    const transferNote = (!hasAnyDefense() && uncoveredIdx()!==-1 && defender()==='you') ? ' (–º–æ–∂–Ω–æ –ø–µ—Ä–µ–≤–µ—Å—Ç–∏ –æ–¥–Ω–æ–∏–º—ë–Ω–Ω–æ–π –∫–∞—Ä—Ç–æ–π)' : '';
    const capNote = ` –ª–∏–º–∏—Ç: ${maxPairs()}`;
    const phase = uncoveredIdx()!==-1? '‚Äî –∑–∞—â–∏—Ç–∞' : (state.table.length? '‚Äî –º–æ–∂–Ω–æ –ø–æ–¥–∫–∏–Ω—É—Ç—å' : '‚Äî –Ω–æ–≤—ã–π –∑–∞—Ö–æ–¥');
    $status.textContent = atk+ '. ' + def + '. ' + phase + transferNote + ' ¬∑ ' + capNote;

    $you.innerHTML='';
    for(const c of state.you){ $you.appendChild(renderCard(c,{ onClick:(ev)=> onYouPlay(c, ev.currentTarget) })); }

    $table.innerHTML='';
    for(const p of state.table){
      const pair=document.createElement('div'); pair.className='pair';
      const a=renderCard(p.a); pair.appendChild(a);
      if(p.d){ const d=renderCard(p.d); d.classList.add('def'); pair.appendChild(d); }
      else { const slot=document.createElement('div'); slot.className='slot'; pair.appendChild(slot); }
      $table.appendChild(pair);
    }

    // Opponent visible backs
    $opponentHand.innerHTML='';
    for(let i=0;i<state.bot.length;i++){ $opponentHand.appendChild(renderBack()); }

    validateState('update');
    checkGameOver();
    saveGame();
  }

  // Animations
  function flyClone(fromRect, toRect, html, duration=320){
    const ghost = document.createElement('div'); ghost.innerHTML = html; const card = ghost.firstElementChild;
    card.style.position='fixed'; card.style.left=fromRect.left+'px'; card.style.top=fromRect.top+'px';
    card.style.margin='0'; card.style.zIndex='9999'; card.style.transform='translate(0px,0px)';
    card.style.transition='transform '+(duration/config.animSpeed)+'ms cubic-bezier(.2,.7,.2,1)';
    document.body.appendChild(card);
    requestAnimationFrame(()=>{ card.style.transform = `translate(${toRect.left - fromRect.left}px, ${toRect.top - fromRect.top}px)`; });
    setTimeout(()=>{ card.remove(); }, (duration/config.animSpeed)+30);
  }
  function animateFromDeckTo(selector){
    update();
    const deckTop = document.querySelector('#deckStack .back');
    const target = document.querySelector(selector);
    if(!deckTop || !target) return;
    const tr = target.getBoundingClientRect(), sr = deckTop.getBoundingClientRect();
    flyClone(sr, tr, '<div class="back"></div>', 300);
  }
  function animateCardMoveById(id, srcEl, dstContainerSelector){
    const fromRect = srcEl.getBoundingClientRect();
    update();
    const dst = document.querySelector(`${dstContainerSelector} [data-id="${id}"]`) || document.querySelector(dstContainerSelector);
    if(!dst) return;
    const toRect = dst.getBoundingClientRect();
    flyClone({left:fromRect.left, top:fromRect.top}, {left:toRect.left, top:toRect.top}, srcEl.outerHTML, 320);
  }
  function animateTableToHand(role){
    const items = Array.from(document.querySelectorAll('#table [data-id]')).map(el => ({id: el.dataset.id, rect: el.getBoundingClientRect(), html: el.outerHTML}));
    update();
    const selector = role==='you' ? '#you' : '#opponentHand';
    const dst = document.querySelector(selector);
    for(const it of items){
      flyClone({left:it.rect.left, top:it.rect.top}, dst.getBoundingClientRect(), it.html, 360);
    }
  }

  // Moves
  document.getElementById('takeBtn').onclick = ()=>{ if(defender()==='you' && uncoveredIdx()!==-1) endBout(true) }
  document.getElementById('bitoBtn').onclick = ()=>{ if(state.attacker==='you' && uncoveredIdx()===-1 && state.table.length){ document.getElementById('bitoConfirmDlg').showModal(); } }

  function ensureBoutStarted(){
    if(!state.bout.started){
      state.bout.started = true;
      state.bout.capacity = Math.min(6, hand(defender()).length);
    }
  }
  function onNewBout(){ state.bout.started=false; state.bout.capacity=6; }

  function onYouPlay(card, srcEl){
    if(state.gameOver) return;
    if(net.mode==='online' && state.attacker!=='you' && defender()!=='you') return;

    if(state.attacker==='you'){
      if(state.table.length===0) ensureBoutStarted();
      if(!canAddAttack()) return;
      if(state.table.length>0 && !ranksOnTable().has(card.rank)) return;
      removeCard(state.you, card);
      state.table.push({a:card, d:null});
      sfx('place'); animateCardMoveById(card.id, srcEl, '#table');
      broadcast({type:'attack', card});
      startTimer(); update(); maybeBot();
    } else {
      const idx=uncoveredIdx(); if(idx===-1) return;
      const target=state.table[idx].a;
      if(canBeat(card, target)){
        removeCard(state.you, card);
        animateCardMoveById(card.id, srcEl, '#table');
        state.table[idx].d=card; sfx('defend');
        broadcast({type:'defend', card});
        startTimer(); update(); maybeBot();
      } else if (canTransferBy('you', card)){
        removeCard(state.you, card);
        state.table.push({a:card, d:null});
        sfx('transfer'); animateCardMoveById(card.id, srcEl, '#table');
        state.attacker = 'you';
        state.bout.started = true;
        state.bout.capacity = Math.min(6, hand('bot').length);
        broadcast({type:'transfer', card, capacity: state.bout.capacity});
        startTimer(); update(); maybeBot();
      }
    }
  }

  function removeCard(handArr, card){ const i=handArr.findIndex(c=>c.id===card.id); if(i>=0) handArr.splice(i,1); }

  // Throw-in flow
  let pendingThrow = null;
  function computeThrowOptions(){
    const rs = ranksOnTable();
    const atkHand = hand(state.attacker);
    const candidates = atkHand.filter(c=>rs.has(c.rank));
    const currentAttacks = state.table.length;
    const limit = Math.max(0, Math.min(state.bout.capacity, 6) - currentAttacks);
    return {limit, candidates};
  }
  function offerThrowIn(){
    const {limit, candidates} = computeThrowOptions();
    if(limit<=0 || candidates.length===0){ finalizeTake(); return; }
    pendingThrow = {limit, selected:new Set(), candidatesIds:new Set(candidates.map(c=>c.id))};
    throwInfo.textContent = `–ú–æ–∂–Ω–æ –æ—Ç–¥–∞—Ç—å –¥–æ ${limit} –∫–∞—Ä—Ç —Ç–µ–º –∂–µ —Ä–∞–Ω–≥–æ–º.`;
    throwGrid.innerHTML='';
    for(const c of hand(state.attacker)){
      if(!pendingThrow.candidatesIds.has(c.id)) continue;
      const el = renderCard(c);
      el.onclick = ()=>{
        if(pendingThrow.selected.has(c.id)){ pendingThrow.selected.delete(c.id); el.style.opacity=''; }
        else { if(pendingThrow.selected.size>=limit) return; pendingThrow.selected.add(c.id); el.style.opacity='0.55'; }
      };
      throwGrid.appendChild(el);
    }
    throwDlg.showModal();
  }
  function commitThrowAndTake(){
    if(!pendingThrow){ throwDlg.close(); finalizeTake(); return; }
    const toAdd = Array.from(pendingThrow.selected);
    const addedCards = [];
    for(const id of toAdd){
      const card = hand(state.attacker).find(c=>c.id===id);
      if(card){
        removeCard(hand(state.attacker), card);
        state.table.push({a:card, d:null});
        addedCards.push(card);
      }
    }
    pendingThrow = null;
    throwDlg.close();
    if(net.mode==='online' && state.attacker==='you'){
      broadcast({type:'throwCommit', cards: addedCards});
    }
    finalizeTake();
  }
  function finalizeTake(){
    const defRole = defender();
    animateTableToHand(defRole);
    const def = hand(defRole);
    for(const p of state.table){ def.push(p.a); if(p.d) def.push(p.d); }
    state.table=[]; sfx('take');
    drawUpToSix(state.attacker); drawUpToSix(defender());
    update();
    startTimer();
    maybeBot();
    onNewBout();
  }

  function endBout(defenderTakes){
    if(defenderTakes){
      if(defender()==='bot' && state.attacker==='you' && net.mode==='offline'){ offerThrowIn(); return; }
      if(net.mode==='online'){ if(state.attacker==='you'){ offerThrowIn(); return; } }
      finalizeTake();
    } else {
      const pile = state.table.slice();
      for(const p of pile){ state.discard.push(p.a); if(p.d) state.discard.push(p.d); }
      state.table=[]; sfx('bito');
      drawUpToSix(state.attacker); drawUpToSix(defender());
      state.attacker = defender();
      update(); startTimer(); maybeBot(); onNewBout();
    }
  }
  function drawUpToSix(role){
    const h=hand(role);
    while(h.length<6 && state.deck.length){
      const ok = draw(h);
      if(ok){ if(role==='you') animateFromDeckTo('#you'); else animateFromDeckTo('#opponentHand'); }
    }
  }
  function draw(handArr){ if(state.deck.length){ handArr.push(state.deck.shift()); return true } return false }

  function checkGameOver(){
    if(state.deck.length===0){
      const h=state.you.length, b=state.bot.length;
      if(h===0 && b>0){ alert('–í—ã –ø–æ–±–µ–¥–∏–ª–∏!'); state.gameOver=true }
      else if(b===0 && h>0){ alert('–û–ø–ø–æ–Ω–µ–Ω—Ç –ø–æ–±–µ–¥–∏–ª.'); state.gameOver=true }
      else if(b===0 && h===0){ alert('–ù–∏—á—å—è ‚Äî –æ–±–∞ –±–µ–∑ –∫–∞—Ä—Ç.'); state.gameOver=true }
    }
  }

  // BOT (auto-take fix preserved)
  function maybeBot(){ if(net.mode==='online') return; setTimeout(()=>{ botTurn() }, 560/config.animSpeed); }
  function botTurn(){
    if(state.gameOver) return;
    const diff = config.difficulty;
    if(state.attacker==='bot'){
      if(uncoveredIdx()!==-1) return;
      if(state.table.length===0){
        ensureBoutStarted();
        let c=botLead(diff);
        if(c){ removeCard(state.bot,c); state.table.push({a:c,d:null}); update(); sfx('place'); startTimer(); maybeBot(); }
      } else {
        if(canAddAttack()){
          const c=botAdd(diff);
          if(c){ removeCard(state.bot,c); state.table.push({a:c,d:null}); update(); sfx('place'); startTimer(); maybeBot(); return }
        }
        setTimeout(()=> endBout(false), config.bitoDelay*1000);
      }
    } else {
      const idx=uncoveredIdx(); if(idx===-1) return;
      const t=state.table[idx].a;
      const cDef=botDef(t, diff);
      if(cDef){ removeCard(state.bot,cDef); state.table[idx].d=cDef; update(); sfx('defend'); startTimer(); maybeBot(); return; }
      const rs=ranksOnTable();
      const trans = !hasAnyDefense() ? state.bot.find(c => rs.has(c.rank) && canTransferBy('bot', c)) : null;
      if(trans){ removeCard(state.bot, trans); state.table.push({a:trans,d:null}); state.attacker = 'bot'; state.bout.started=true; state.bout.capacity=Math.min(6, hand('you').length); update(); sfx('transfer'); startTimer(); maybeBot(); }
      else { endBout(true); }
    }
  }
  function botLead(diff){
    const non = state.bot.filter(c=>c.suit!==state.trump).sort((a,b)=>rankVal(a.rank)-rankVal(b.rank));
    const tr = state.bot.filter(c=>c.suit===state.trump).sort((a,b)=>rankVal(a.rank)-rankVal(b.rank));
    if(diff==='easy'){ return non[0] || tr[0] }
    if(diff==='hard'){ return (non[0] && rankVal(non[0].rank)<=9) ? non[0] : (tr[0] || non[0]) }
    return non[0] || tr[0];
  }
  function botAdd(diff){
    const rs=ranksOnTable();
    const cand = state.bot.filter(c=>rs.has(c.rank));
    if(cand.length===0) return null;
    cand.sort((a,b)=> (a.suit===state.trump)-(b.suit===state.trump) || (rankVal(a.rank)-rankVal(b.rank)));
    if(diff==='easy') return cand[0];
    if(diff==='hard') return cand.find(c=>c.suit!==state.trump) || cand[0];
    return cand[0];
  }
  function botDef(target, diff){
    const cand=state.bot.filter(c=>canBeat(c,target)).sort((a,b)=>{
      if(a.suit===b.suit) return rankVal(a.rank)-rankVal(b.rank);
      if(a.suit===target.suit && b.suit===state.trump) return -1;
      if(a.suit===state.trump && b.suit===target.suit) return 1;
      return (a.suit===state.trump)-(b.suit===state.trump);
    });
    if(diff==='easy') return cand[0] || null;
    if(diff==='hard'){
      const same = cand.find(c=>c.suit===target.suit);
      return same || cand[0] || null;
    }
    return cand[0] || null;
  }

  // ONLINE
  let netState = document.getElementById('netState');
  const onlineDlg = document.getElementById('onlineDlg');
  document.getElementById('onlineClose').onclick = ()=> onlineDlg.close();
  document.getElementById('hostCreate')?.addEventListener('click', async ()=>{
    await createPeer('host');
    hostOffer.value = btoa(JSON.stringify(await net.pc.createOffer()));
    await net.pc.setLocalDescription(JSON.parse(atob(hostOffer.value)));
    netState.textContent = '–°–∫–æ–ø–∏—Ä—É–π—Ç–µ –æ—Ñ—Ñ–µ—Ä –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –¥—Ä—É–≥—É.';
  });
  document.getElementById('hostCopy')?.addEventListener('click', async ()=> { try{ await navigator.clipboard.writeText(hostOffer.value); }catch(e){} });
  document.getElementById('hostPaste')?.addEventListener('click', async ()=> { try{ hostAnswer.value = await navigator.clipboard.readText(); }catch(e){} });
  document.getElementById('hostSetAnswer')?.addEventListener('click', async ()=>{
    const ans = JSON.parse(atob(hostAnswer.value.trim()));
    await net.pc.setRemoteDescription(ans);
    netState.textContent = '–û–∂–∏–¥–∞–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è‚Ä¶';
  });
  document.getElementById('guestPasteOffer')?.addEventListener('click', async ()=> { try{ guestOffer.value = await navigator.clipboard.readText(); }catch(e){} });
  document.getElementById('guestCreateAnswer')?.addEventListener('click', async ()=>{
    await createPeer('guest');
    const off = JSON.parse(atob(guestOffer.value.trim()));
    await net.pc.setRemoteDescription(off);
    const answer = await net.pc.createAnswer();
    await net.pc.setLocalDescription(answer);
    guestAnswer.value = btoa(JSON.stringify(answer));
    netState.textContent = '–°–∫–æ–ø–∏—Ä—É–π—Ç–µ —ç—Ç–æ—Ç –æ—Ç–≤–µ—Ç –¥—Ä—É–≥—É.';
  });
  document.getElementById('guestCopyAnswer')?.addEventListener('click', async ()=> { try{ await navigator.clipboard.writeText(guestAnswer.value); }catch(e){} });

  async function createPeer(role){
    net = { mode:'online', role, pc: new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]}), dc:null, ready:false };
    net.pc.oniceconnectionstatechange = ()=> netState.textContent = 'ICE: '+net.pc.iceConnectionState;
    net.pc.onconnectionstatechange = ()=> netState.textContent = 'RTC: '+net.pc.connectionState;
    if(role==='host'){
      net.dc = net.pc.createDataChannel('game');
      wireDataChannel(net.dc);
      net.pc.onicecandidate = (e)=>{ if(!e.candidate){ hostOffer.value = btoa(JSON.stringify(net.pc.localDescription)); } };
    } else {
      net.pc.ondatachannel = (e)=> { net.dc = e.channel; wireDataChannel(net.dc); };
      net.pc.onicecandidate = (e)=>{ if(!e.candidate){ guestAnswer.value = btoa(JSON.stringify(net.pc.localDescription)); } };
    }
  }
  function wireDataChannel(dc){
    dc.onopen = ()=>{ net.ready = true; netState.textContent = '–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ'; startOnlineMatch(); };
    dc.onclose = ()=>{ net.ready = false; netState.textContent = '–ö–∞–Ω–∞–ª –∑–∞–∫—Ä—ã—Ç'; };
    dc.onmessage = (e)=> onNetMessage(JSON.parse(e.data));
  }
  function broadcast(obj){ if(net.mode==='online' && net.ready){ net.dc.send(JSON.stringify(obj)); } }

  function startOnlineMatch(){
    if(net.role==='host'){
      state.deck = newDeck();
      state.you=[]; state.bot=[]; state.table=[]; state.discard=[]; state.gameOver=false; state.attacker='you'; state.bout={capacity:6, started:false};
      deal(true);
      decideFirst();
      broadcast({type:'sync', state, cardAutoId});
      update(); startTimer();
    }
  }
  function decideFirst(){
    const lowest = (hand)=> hand.filter(c=>c.suit===state.trump).sort((a,b)=>rankVal(a.rank)-rankVal(b.rank))[0];
    const h=lowest(state.you), b=lowest(state.bot);
    if(h && b) state.attacker = (rankVal(h.rank)<rankVal(b.rank))?'you':'bot'; else if(h) state.attacker='you'; else if(b) state.attacker='bot'; else state.attacker=Math.random()<.5?'you':'bot';
  }

  function onNetMessage(msg){
    if(msg.type==='sync'){
      Object.assign(state, msg.state);
      cardAutoId = msg.cardAutoId;
      const tmp = state.you; state.you = state.bot; state.bot = tmp;
      state.attacker = (state.attacker==='you') ? 'bot' : 'you';
      update(); startTimer();
    } else if(msg.type==='attack'){
      if(state.table.length===0) ensureBoutStarted();
      state.table.push({a:msg.card, d:null}); update(); sfx('place'); startTimer();
    } else if(msg.type==='defend'){
      const idx=uncoveredIdx(); if(idx!==-1){ state.table[idx].d=msg.card; update(); sfx('defend'); startTimer(); }
    } else if(msg.type==='transfer'){
      state.table.push({a:msg.card, d:null}); state.attacker='bot'; state.bout.started=true; state.bout.capacity = msg.capacity ?? Math.min(6, hand('you').length); update(); sfx('transfer'); startTimer();
    } else if(msg.type==='throwCommit'){
      for(const c of msg.cards){ state.table.push({a:c, d:null}); }
      update();
    } else if(msg.type==='endBout'){
      endBout(msg.defenderTakes);
    } else if(msg.type==='chat'){
      const old = $status.textContent; $status.textContent = '–î—Ä—É–≥: '+msg.emo; setTimeout(()=>{ $status.textContent = old; }, 1200);
    }
  }

  // Save / Load
  function saveGame(){ if(!config.autosave) return; const snapshot = { state, cardAutoId }; try { localStorage.setItem(gameKey, JSON.stringify(snapshot)); } catch(e){} }
  function loadGame(){
    try{ const raw = localStorage.getItem(gameKey); if(!raw) return false; const snap = JSON.parse(raw); Object.assign(state, snap.state); cardAutoId = snap.cardAutoId || 0; update(); return true; }catch(e){ return false }
  }

  // Validation
  function validateState(origin=''){
    let ok = true, msg = '';
    if(state.table.length > maxPairs()){ ok=false; msg='–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∫–∞—Ä—Ç –Ω–∞ —Å—Ç–æ–ª–µ (–ª–∏–º–∏—Ç –∑–∞—Ö–æ–¥–∞)'; }
    for(const p of state.table){
      if(p.d && !canBeat(p.d, p.a)){ ok=false; msg='–ù–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è –∑–∞—â–∏—Ç–∞ –Ω–∞ —Å—Ç–æ–ª–µ'; break; }
    }
    if(!ok){ console.warn('validateState:', msg, 'origin=', origin, JSON.parse(JSON.stringify(state))); showToast('–õ–æ–≥–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: '+msg); }
    return ok;
  }

  // Boot
  function deal(animated=false){
    for(let i=0;i<6;i++){ if(draw(state.you) && animated) animateFromDeckTo('#you'); if(draw(state.bot) && animated) animateFromDeckTo('#opponentHand'); sfx('deal'); }
  }
  function start(newMatch=true){
    if(newMatch || !loadGame()){
      state.deck = newDeck();
      state.you=[]; state.bot=[]; state.table=[]; state.discard=[]; state.gameOver=false; state.attacker='you'; state.bout={capacity:6, started:false};
      deal(true); decideFirst(); update(); startTimer(); maybeBot();
      saveGame();
    } else { startTimer(); maybeBot(); }
  }
  start();
})();
</script>
<script src="sw-helper.js" defer></script>
</body>
</html>
